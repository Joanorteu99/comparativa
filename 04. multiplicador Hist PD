/*Tabla PD Particulars*/

%LET PD_PART_H_3 = CLIMRISK.TD_PART_PROY_H_1125; /*tabla con proyecciones PD (1 de 2)*/

/*empresa y particulares*/
proc sql; create table a as select * from CLIMRISK.TD_OUTPUT_2025_61S ;run;
proc sql; create table b as select * from CLIMRISK.TD_OUTPUT_2025_19S ;run;
proc sql; create table c as select * from CLIMRISK.TD_PART_PROY_H_3_1024 ;run;
proc sql; create table d as select * from CLIMRISK.TD_OUTPUT_2025_19S_PONDXTITU ;run;
/*para la versión con 19 sectores hay que utilizar la variable Sector en vez de Subsector 
Aunque hay 21! hay que preguntar*/
/*tabla con proyecciones PD (1 de 2)*/
/*proc sql;*/
/*create table tm_proj_1 as select Sector as Subsector, year, scenario, tm_pred as tm_Pred*/
/*from CLIMRISK.TD_OUTPUT_2025_19S as t2*/
/*group by Subsector, year, scenario;*/
/*quit;*/

proc sql;
	create table TD_OUTPUT_2025_19S as
	select Sector, Scenario, Year, TM_Pred_Pond as TM_Pred
	from CLIMRISK.TD_OUTPUT_2025_19S_PONDXTITU
;run;

proc sql;
	create table TD_OUTPUT_2025_19S as
	select a.Sector, a.Scenario, a.Year,
		case when a.Year >= 2025 then b.TM_Pred_Pond else a.TM_Pred end as TM_Pred
	from CLIMRISK.TD_OUTPUT_2025_19S as a
	left join CLIMRISK.TD_OUTPUT_2025_19S_PONDXTITU as b
		on a.sector = b.sector and a.Scenario = b.Scenario and a.Year = b.Year
;run;

proc sql;
    create table factor_sequia as
    select 
        sector as Subsector,
        (max(case when Year = 2026 then TM_Pred end) /
        max(case when Year = 2025 then TM_Pred end) - 1) / 25 + 1 as factor_sequia
    from TD_OUTPUT_2025_19S
    where Scenario = "Drought"
          and Year in (2025, 2026)
    group by sector;
quit;

proc sql;
    create table tm_proj_1 as
    select 
        a.sector as Subsector, a.Scenario, a.Year,
        case 
            when a.Scenario = "Drought" and a.Year <= 2025 then a.TM_Pred 
			when a.Scenario = "Drought" and a.Year >= 2026 then b.TM_Pred * f.factor_sequia
            when a.Scenario = "DIRE" and a.Year > 2030 then b.TM_Pred
            when a.Scenario = "DAPS" and a.Year > 2030 then b.TM_Pred
            else a.TM_Pred
        end as TM_Pred

    from TD_OUTPUT_2025_19S as a
    left join factor_sequia as f
        on a.sector = f.Subsector
    left join (select * from TD_OUTPUT_2025_19S where scenario = "Hot_house_world") as b
        on a.sector = b.sector and a.Year = b.Year
;quit;





data tm_proj_2;
	set tm_proj_1;
	if year = 2021 or year = 2022 or year = 2023 then Scenario = "Historico";
run;

proc sql;
	create table tm_proj as select distinct
		*
	from tm_proj_2;
quit;

/*------NEW------ Reorganitzar informació, volem una columa d'anys, escenaris i una per a cada TM per a cada sector*/
proc sort data=tm_proj_2 nodupkey;
	by year scenario Subsector;
run;
proc transpose data=tm_proj_2 out=TMs prefix=tm_;
	by year scenario;
	id Subsector;           /* Cada Subsector será una columna */
	var TM_Pred;            /* Valores a pivotar */
run;
data TMs;
	set TMs;
	drop _name_;
run;
/*---------------*/

proc sql;
create table particulares as select t1.year, t1.scenario, t1.tm as tm_particular_h0
from &PD_PART_H_3. as t1;
quit;

data particulares_mod_1;
	set particulares;
	if scenario IN("Historical","Historico") then scenario = "Historico";
	if year = 2022 or year = 2023 then scenario = "Historico";
run;

proc sql;
	create table particulares_mod as select distinct
		*
	from particulares_mod_1;
quit;




proc sql;
create table tms_totales as select t1.*, t2.tm_particular_h0
from TMs as t1
left join particulares_mod as t2 
	on (t1.year = t2.year and t1.scenario = 'Drought' and  t2.scenario='Hot_house_world') 
	or (t1.year = t2.year and t1.scenario not in ('Drought') and  t1.scenario=t2.scenario);
quit;


proc sql;
create table tm_historico as select
*
from tms_totales
where scenario in ('Historico');
quit;

/* --------------------- new ---------------------- */

/*=======================================================================*/
/*Calculo de variables intermedias para la z*/
/*=======================================================================*/

%macro calcular_rho_aux(data=tm_historico, out=rho_historico);
/* 1. Identificar todas las columnas TM_ */
proc contents data=&data out=vars(keep=name) noprint;
run;

proc sql noprint;
    select name
    into :tm_list separated by ' '
    from vars
    where upcase(name) like "TM_%"
    ;
quit;

%put Variables TM detectadas: &tm_list;

/* 2. Crear sentencias dinámicas para el cálculo de RHO */
%let n = %sysfunc(countw(&tm_list));

%let rho_expr=;

%do i=1 %to &n;

	/*número de TM*/
    %let var = %scan(&tm_list, &i);
	%let base = %substr(&var, 4);  

	/*Nombre variables*/
	%let rhoname = rho_a_&base;
	%let avgname = avg_&base;
	%let rhoavg_name = rhoavg_&base;
	%let rhofinalname = rho_final_&base;
	%let varname = var_&base;
	%let stdname = std_&base;
	
	/*formulitas*/
	%if %index(&var, h0) > 0 %then %do;
    	%let rhoavg_expr = 0.15;
	%end;
	%else %do;
	    %let rhoavg_expr =
	        0.12*(1-exp(-50*avg(&var))/(1-exp(-50))) + 0.24*(1 - (1-exp(-50*avg(&var))/(1-exp(-50))));
	%end;
    /* construir expresiones */
    %let piece = 
        var(probit(&var))/(1+var(probit(&var))) as &rhoname,
        avg(&var) as &avgname,
        (&rhoavg_expr) as &rhoavg_name,
		max( var(probit(&var))/(1+var(probit(&var))), (&rhoavg_expr) ) as &rhofinalname,
		var(&var) as &varname,
		std(&var) as &stdname;

    /* combinar en una única lista */
    %if &i = 1 %then %let expr_list = &piece;
    %else %let expr_list = &expr_list, &piece;
%end;

/* 3. Ejecutar SQL final */
proc sql;
    create table &out as
    select distinct
        &expr_list
    from &data;
quit;


%mend calcular_rho_aux;

/*============================================================*/
/*             EJECUTAR LA MACRO                              */
/*============================================================*/
%calcular_rho_aux(data=tm_historico, out=rho_historico_aux);

/*============================================================*/
/* creo unas tablas intermedias para ejecuciones de otros flujos  */
/*============================================================*/

%macro extract_and_rename(in=, out=, prefix=, newprefix=);

proc datasets library=work nolist;
    delete &out;
quit;

/* 1. Detectar variables */
proc contents data=&in out=vars(keep=name) noprint; run;

proc sql noprint;
    select name
    into :varlist separated by ' '
    from vars
    where upcase(name) like ("%UPCASE(&prefix)%")
    ;
quit;

%put Variables detectadas: &varlist;

/* si no hay variables, salir */
%if "&varlist" = "" %then %do;
    %put WARNING: No matching vars for prefix &prefix in &in;
    %return;
%end;

/* 2. Construir lista rename */
%let n = %sysfunc(countw(&varlist));
%let rename_list=;

%do i=1 %to &n;

    %let old = %scan(&varlist,&i);
    %let base = %substr(&old, %length(&prefix)+1);
    %let new = &newprefix.&base;

    /* evitar rename redundantes */
    %if "&old" ne "&new" %then %do;
        %if "&rename_list" = "" 
            %then %let rename_list = &old = &new;
            %else %let rename_list = &rename_list  &old = &new;
    %end;

%end;

/* 3. Copiar solo esas columnas */
data &out;
    set &in(keep=&varlist);
run;

/* 4. Renombrar (solo si hay algo que renombrar) */
%if "&rename_list" ne "" %then %do;
    proc datasets library=work nolist;
        modify &out;
        rename &rename_list;
    quit;
%end;

%mend extract_and_rename;



/*llamar a la macro: Generar tablas para los flujos siguientes*/

%extract_and_rename(in=rho_historico_aux, out=rho_historico, prefix=rho_a_, newprefix=rho_);
%extract_and_rename(in=rho_historico_aux, out=media_historico, prefix=avg_, newprefix=avg_);


/*============================================================*/
/*  MACRO PER CALCULAR TOTS ELS Z_XXX AUTOMÀTICAMENT         */
/*============================================================*/

%macro calcular_z(tmtable=tm_historico, rhotable=rho_historico_aux, input_rho = rho, out=z_historico);
/* 1. Detectar totes les variables TM_ */
proc contents data=&tmtable out=vars_tm(keep=name) noprint; run;
proc sql noprint;
    select name
    into :tm_list separated by ' '
    from vars_tm
    where upcase(name) like "TM_%"
    ;
quit;
/* 2. Generar expressions z_XXX */
%let n = %sysfunc(countw(&tm_list));
%let z_expr = ;

%do i=1 %to &n;
    %let tmvar = %scan(&tm_list, &i);       /* tm_111, tm_24_h0 */
    %let base  = %substr(&tmvar, 4);        /* 111  o 24_h0     */

    %let avgvar = avg_&base;
    %let rhovar = &input_rho._&base;
    %let zname  = z&base;

    %let this_expr =
        ( probit(t1.&tmvar)*sqrt(1 - t3.&rhovar) - probit(t3.&avgvar) )
        /
        ( -sqrt(t3.&rhovar) )
        as &zname
    ;

    %if &i=1 %then %let z_expr = &this_expr;
    %else %let z_expr = &z_expr, &this_expr;

%end;

/* 3. JOIN i càlcul */
proc sql;
    create table &out as
    select distinct
        t1.year,
        &z_expr
    from &tmtable as t1
    left join &rhotable as t3
    on 1=1
    ;
quit;

%mend calcular_z;


/*============================================================*/
/*          EXECUTAR LA MACRO                                */
/*============================================================*/

%calcular_z(tmtable=tm_historico, rhotable=rho_historico_aux,input_rho = rho_a, out=z_historico);
%calcular_z(tmtable=tm_historico, rhotable=rho_historico_aux,input_rho = rhoavg, out=z_historico_reg);
%calcular_z(tmtable=tm_historico, rhotable=rho_historico_aux,input_rho = rho_final, out=z_historico_max);


/*============================================================*/
/*   MACRO PER CALCULAR UNA ESTADÍSTICA SOBRE TOTES LES Z_   */
/*============================================================*/

%macro stats_z(in=z_rho, out=stats_rho_var, stat=std);

/* 1. Detectar todas las variables Z_ */
proc contents data=&in out=vars(keep=name) noprint;
run;

proc sql noprint;
    select name
    into :z_list separated by ' '
    from vars
    where upcase(name) like "Z_%"
    ;
quit;

%put Variables Z detectadas: &z_list;

/* 2. Construir expresiones dinamicas */
%let n = %sysfunc(countw(&z_list));
%let expr_list = ;

%do i=1 %to &n;

    %let zvar = %scan(&z_list, &i);   /* ex: z_111 */
    %let base = %substr(&zvar, 2);    /* quitar z_ -> 111 */

    /* Nombre de la variable resultado: ex. std_111 */
    %let outname = &stat._&base;

    %let expr = &stat(&zvar) as &outname;

    %if &i=1 %then %let expr_list = &expr;
    %else %let expr_list = &expr_list, &expr;

%end;

/* 3. Generar tabla de salida */
proc sql;
    create table &out as
    select
        &expr_list
    from &in
    ;
quit;

%mend stats_z;


%stats_z(in=z_historico, out=std_z_historico, stat=std);
%stats_z(in=z_historico, out=std_z_historico_reg, stat=std);
%stats_z(in=z_historico, out=std_z_historico_max, stat=std);

%stats_z(in=z_historico, out=media_z_historico, stat=avg);
%stats_z(in=z_historico, out=media_z_historico_reg, stat=avg);
%stats_z(in=z_historico, out=media_z_historico_max, stat=avg);


/*============================================================*/
/*   MACRO PER FER PROC CORR AMB TOTES LES VARIABLES TM_      */
/*============================================================*/

%macro corr_tm(data=tm_historico, out=corrtabla);

/* 1. Detectar totes les variables TM_ */
proc contents data=&data out=vars(keep=name) noprint; run;

proc sql noprint;
    select name
    into :tm_list separated by ' '
    from vars
    where upcase(name) like "TM_%"
    ;
quit;

/* Mostrar llista detectada */
%put Variables TM detectades per CORR: &tm_list;

/* 2. Executar PROC CORR */
ods output pearsoncorr=&out;

proc corr 
     data=&data 
     noprob 
     nosimple 
     pearson;
    var &tm_list;
run;

ods output close;

%mend corr_tm;

%corr_tm(data=tm_historico, out=corrtabla);
